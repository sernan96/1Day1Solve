#include <iostream>
using namespace std;

int solution(int n)
{
    int ans = 0;
    while(n>0){
        if(n % 2==0){
            n/=2;
        }
        else{
            n--;
            ans++;
        }
    }

    return ans;
}
/*
이동 방법
1. K칸 점프 (건전지 사용량 K)
2. 이동한 만큼 순간이동 (건전지 사용량 0)

BFS를 통해서 각 상태마다 2번이 가능하다면
1번과 2번 방법 모두 시도해서 다음 큐로 넣어주고 
그게 아니라면 1번만 시도해서 
다음번 위치, 건전지 사용량을 넣어준다.

그런데 N이 10억이하의 자연수이므로 모든 경우의 수에 대해서 진행을 하면 시간초과가 발생할 듯 하다.

그래서 생각한 다른 방법은
DP를 통해서 10억개의 배열 또는 map을 활용한 방법을 사용하더라도 메모리나 시간에서 초과가 날듯하다.
그렇기에 N부터 역으로 짝수일 경우 N/2를 해가며 수를 줄이는 방법이 어떤지 생각해보았다.
5일 경우 
5 - 1;
4 /2
2 /2
1 - 1;
6일 경우
6/2
3--
2/2
1--
5000일 경우
5000/2
2500/2
1250/2
625--
624/2
312/2
156/2
78/2
39--
38/2
19--
18/2
9--
8/2
4/2
2/2
1--
의 접근이 타당해 보인다.
*/